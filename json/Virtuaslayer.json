{
  "name": "virtuaslayer",
  "description": "Virtuaslayer is a first person shooter game made in a custom 2D game engine that takes place in the glitchy world of the users computer as they fight viruses from too many downloads.",
  "video": "https://drive.google.com/file/d/0B4_dbFq47deYYnl1alNNV2NlMzQ/preview",
  "snippets": [
    [ "\/*Que Sectors in order to be rendered. Starts by checking if a sector has a portal to another sector in view, \n  and then recursivley checks sectors in view \n  Parameters:\n    que: deque to use to store sectors in rendering order, start: the sector to start looking in\n    sectNum: The number of the starting sector, LastSect: The last sector checked (used in recursion)\n    Qued: pointer to number of sectors qued. *\/\nvoid QueSectors(std::deque<Sector> *que, Sector start, int SectNum, int LastSect, int *Qued)\n{\n  \/\/Go through each vertex in the sector\n\tfor (int i = 0; i < start.numverticies; ++i)\n\t{\n\t\tif (start.portal[i])\n      \/\/If the located portal does not lead back to the previous sector\n\t\t\tif (!(start.portalSects[i].x == LastSect || start.portalSects[i].y == LastSect))\n\t\t\t{\n        \/\/If the portal is visible\n\t\t\t\tif ((InFov(start.vertices[i]) || InFov(start.vertices[i + 1])\n\t\t\t\t\t|| FovBetweenPoints(start.vertices[i], start.vertices[i + 1]))\n\t\t\t\t\t&& !(NoIntersectWithWallinSector(start.vertices[i], SectNum)\n\t\t\t\t\t\t&& NoIntersectWithWallinSector(start.vertices[i + 1], SectNum)))\n\t\t\t\t{\n          \/\/Check where the portal leads and update the deque\n\t\t\t\t\tint sec1 = (int)start.portalSects[i].x, sec2 = (int)start.portalSects[i].y, nextSect;\n\t\t\t\t\tif (SectNum == sec1)\n\t\t\t\t\t{\n\t\t\t\t\t\tque->push_back(sectors[sec2]);\n\t\t\t\t\t\tnextSect = sec2;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tque->push_back(sectors[sec1]);\n\t\t\t\t\t\tnextSect = sec1;\n\t\t\t\t\t}\n\t\t\t\t\t++*Qued;\n          \/\/If the next sector leads somewhere\n\t\t\t\t\tif (sectors[nextSect].numportals > 1)\n\t\t\t\t\t\tQueSectors(que, sectors[nextSect], nextSect, SectNum, Qued);\n\t\t\t\t}\n\t\t\t}\n\t}\n}", "This code was used to recursivley add each sector (room) to the rendering que in the correct order. The actual map data is a list of 2D points made in a top down perspective. After being translated to 3D planes, this function orders them from the perspective of the player" ],
    [ "vsverts.png", "This is a visual representation of how the map data is stored in the level files" ],
    [ "compfunc.png", "This function allowed for dynamically adding components to an object by accepting any component of any type, and as many as needed by using a variadic templated function" ]
  ]
}